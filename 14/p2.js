var url = "https://adventofcode.com/2021/day/14/input";
var testData = `NNCB

CH -> B
HH -> N
CB -> H
NH -> C
HB -> C
HC -> B
HN -> C
NN -> C
BH -> H
NC -> B
NB -> B
BN -> B
BB -> N
BC -> B
CC -> N
CN -> C`;

class HashCount {
	constructor(set) {
		this.count = {};
		
		if (set) {
			if (set.constructor === HashCount) {
				for (var key in set.count) {
					this.count[key] = set.count[key];
				}
			}
			else if (Array.isArray(set)) {
				this.count = set
					.reduce((acc, x) => {
						acc[x] = (acc[x] || 0) + 1;
						return acc;
					}, {});
			}
			else {
				this.count[set] = 1;
			}
		}
	}
	add(value) {
		this.count[value] = (this.count[value] || 0) + 1;
	}
	remove(value) {
		this.count[value] = (this.count[value] || 1) - 1;
	}
	union(hashCount) {
		var result = new HashCount(this);
		
		for (var key in hashCount.count) {
			result.count[key] = (result.count[key] || 0) + hashCount.count[key];
		}
		
		return result;
	}
}

function getInput(isTest) {
	return isTest
		? new Promise((resolve, reject) => resolve(testData))
		: fetch(url).then(res => res.text());
}

await getInput(false)
	.then(input => {
		input = input
			.split("\n\n");
		
		var polymerTemplate = input[0];
		var rules = input[1]
			.split("\n")
			.filter(x => x)
			.map(x => x
				.split(" -> "));
		
		var currRuleResult = rules
			.reduce((acc, x) => {
				acc[x[0]] = new HashCount(x[1]);
				return acc;
			}, {});
			
		// Had to make the solution work for a larger number of iterations.
		// Instead of directly working with the list, can iteratively calculate the number of each character generated by each pair
			// Each pair generates a character, so the result is the character generated + all characters that the resulting pairs would generate in future generations
		
		// e.g. If:
		//		AA -> B
		//		AB -> A
		//		BA -> B
		//		BB -> A
		// Then after 1 generation:
		//		AA -> { B: 1 }
		//		AB -> { A: 1 }
		//		BA -> { B: 1 }
		//		BB -> { A: 1 }
		// 2 generations:
		//		AA -> { B: 1 } union AB union BA = { A: 1, B: 2 }
		//		AB -> { A: 1 } union AA union AB = { A: 2, B: 1 }
		//		BA -> { B: 1 } union BB union BA = { A: 1, B: 2 }
		//		BB -> { A: 1 } union BA union AB = { A: 2, B: 1 }
		// 3 generations:
		//		AA -> { B: 1 } union AB union BA = { A: 3, B: 4 }
		//		AB -> { A: 1 } union AA union AB = { A: 4, B: 3 }
		//		BA -> { B: 1 } union BB union BA = { A: 3, B: 4 }
		//		BB -> { A: 1 } union BA union AB = { A: 4, B: 3 }
		// etc.
		
		// Start with i = 1 because one generation is already represented by the initial rules
		
		for (var i = 1; i < 40; i++) {
			var nextRuleResult = {};
			
			for (var j = 0; j < rules.length; j++) {
				var rule = rules[j];
				
				var pair1 = rule[0][0] + rule[1];
				var pair2 = rule[1] + rule[0][1];
				
				var result1 = currRuleResult[pair1];
				var result2 = currRuleResult[pair2];
				
				nextRuleResult[rule[0]] = new HashCount(rule[1]).union(result1).union(result2);
			}
			
			currRuleResult = nextRuleResult;
		}
		
		var result = new HashCount(polymerTemplate.split(""));
		
		for (var i = 0; i < polymerTemplate.length - 1; i++) {
			var pair = polymerTemplate[i] + polymerTemplate[i + 1];
			if (currRuleResult[pair]) {
				result = result.union(currRuleResult[pair]);
			}
		}
		
		
		return Math.max(...Object.values(result.count)) - Math.min(...Object.values(result.count));
	});